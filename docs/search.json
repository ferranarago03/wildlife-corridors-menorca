[
  {
    "objectID": "src/sections/problem_statement_eda.html",
    "href": "src/sections/problem_statement_eda.html",
    "title": "Exploratory Data Analysis",
    "section": "",
    "text": "Code\nimport folium\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import rgb2hex\nimport numpy as np\n\ndataset_gpd = gpd.read_file(\n    \"https://gitlab.com/drvicsana/opt-milp-project-2025/-/raw/main/datasets/dataset.geojson\"\n)",
    "crumbs": [
      "Article",
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "src/sections/problem_statement_eda.html#available-data",
    "href": "src/sections/problem_statement_eda.html#available-data",
    "title": "Exploratory Data Analysis",
    "section": "Available Data",
    "text": "Available Data\nThe dataset contains the following attributes for each cell in the discretized map of Menorca:\n\n\n\n\n\n\n\n\nAttribute\nDescription\nDomain\n\n\n\n\ngrid_id\nIdentifier of a cell in Menorca’s map (column and row number)\nString\n\n\ndominant_land_cover_name\nDominant type of land in the cell\nString\n\n\ncost_adaptation_atelerix\nCost of making some adaptations in the cell for the atelerix\nFloat\n\n\ncost_adaptation_martes\nCost of making some adaptations in the cell for the martes martes\nFloat\n\n\ncost_adaptation_eliomys\nCost of making some adaptations in the cell for the eliomys quercinus\nFloat\n\n\ncost_adaptation_oryctolagus\nCost of making some adaptations in the cell for the oryctolagus cuniculus\nFloat\n\n\ncost_corridor\nCost of preparing a single corridor in the cell\nFloat\n\n\nhas_atelerix_algirus\nWhether or not the cell has a living colony of atelerix\nBoolean\n\n\nhas_martes_martes\nWhether or not the cell has a living colony of martes martes\nBoolean\n\n\nhas_eliomys_quercinus\nWhether or not the cell has a living colony of eliomys quercinus\nBoolean\n\n\nhas_oryctolagus_cuniculus\nWhether or not the cell has a living colony of european rabbit\nBoolean\n\n\ngeometry\nThe polygon that describes the cell\nGeometry",
    "crumbs": [
      "Article",
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "src/sections/problem_statement_eda.html#corridor-cost-analysis",
    "href": "src/sections/problem_statement_eda.html#corridor-cost-analysis",
    "title": "Exploratory Data Analysis",
    "section": "Corridor Cost Analysis",
    "text": "Corridor Cost Analysis\nWe observe that the distribution of corridor costs is normally distributed.\n\nplt.figure(figsize=(10, 6))\nplt.hist(dataset_gpd[\"cost_corridor\"], bins=25, edgecolor=\"black\")\nplt.xlabel(\"Cost of Corridor\")\nplt.ylabel(\"Frequency\")\nplt.title(\"Distribution of Cost of corridor\")\nplt.show()",
    "crumbs": [
      "Article",
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "src/sections/problem_statement_eda.html#adaptation-analysis",
    "href": "src/sections/problem_statement_eda.html#adaptation-analysis",
    "title": "Exploratory Data Analysis",
    "section": "Adaptation Analysis",
    "text": "Adaptation Analysis\nHere is analysed the adaptation for the four species considered in the project: Oryctolagus cuniculus, Eliomys quercinus, Martes martes and Atelerix algirus.\n\nSustainability Scores\nFirstly, is important to assign a suitability score to each land cover type for each species. These scores are based on ecological studies and expert opinions regarding the habitat preferences of each species.\n\n\nCode\nsuitability_cuniculus = {\n    \"Discontinuous Urban Fabric\": \"Low\",\n    \"Continuous Urban Fabric\": \"Very Low\",\n    \"Industrial or Commercial Units\": \"Very Low\",\n    \"Airports\": \"Very Low\",\n    \"Port Areas\": \"Very Low\",\n    \"Sport and Leisure Facilities\": \"Very Low\",\n    \"Pastures\": \"High\",\n    \"Non-irrigated Arable Land\": \"High\",\n    \"Permanently Irrigated Land\": \"Low\",\n    \"Complex Cultivation Patterns\": \"High\",\n    \"Land Principally Occupied by Agriculture with Significant Areas of Natural Vegetation\": \"High\",\n    \"Sclerophyllous Vegetation\": \"High\",\n    \"Transitional Woodland-Shrub\": \"High\",\n    \"Natural Grasslands\": \"High\",\n    \"Broad-leaved Forests\": \"Moderate\",\n    \"Mixed Forests\": \"Moderate\",\n    \"Coniferous Forests\": \"Low-Moderate\",\n    \"Peatbogs\": \"Very Low\",\n    \"Inland Marshes\": \"Very Low\",\n    \"Coastal Lagoons\": \"Very Low\",\n    \"Estuaries\": \"Very Low\",\n    \"Intertidal Flats\": \"Very Low\",\n    \"Water Courses\": \"Low\",\n}\n\nsuitability_quercinus = {\n    \"Discontinuous Urban Fabric\": \"Low\",\n    \"Continuous Urban Fabric\": \"Very Low\",\n    \"Industrial or Commercial Units\": \"Very Low\",\n    \"Airports\": \"Very Low\",\n    \"Port Areas\": \"Very Low\",\n    \"Sport and Leisure Facilities\": \"Very Low\",\n    \"Pastures\": \"Low\",\n    \"Non-irrigated Arable Land\": \"Low\",\n    \"Permanently Irrigated Land\": \"Very Low\",\n    \"Complex Cultivation Patterns\": \"Moderate\",\n    \"Land Principally Occupied by Agriculture with Significant Areas of Natural Vegetation\": \"Moderate-High\",\n    \"Sclerophyllous Vegetation\": \"High\",\n    \"Transitional Woodland-Shrub\": \"High\",\n    \"Natural Grasslands\": \"Low\",\n    \"Broad-leaved Forests\": \"High\",\n    \"Mixed Forests\": \"High\",\n    \"Coniferous Forests\": \"Moderate-High\",\n    \"Peatbogs\": \"Very Low\",\n    \"Inland Marshes\": \"Very Low\",\n    \"Coastal Lagoons\": \"Very Low\",\n    \"Estuaries\": \"Very Low\",\n    \"Intertidal Flats\": \"Very Low\",\n    \"Water Courses\": \"Low-Moderate\",\n}\n\nsuitability_martes = {\n    \"Discontinuous Urban Fabric\": \"Low\",\n    \"Continuous Urban Fabric\": \"Very Low\",\n    \"Industrial or Commercial Units\": \"Very Low\",\n    \"Airports\": \"Very Low\",\n    \"Port Areas\": \"Very Low\",\n    \"Sport and Leisure Facilities\": \"Very Low\",\n    \"Pastures\": \"Low\",\n    \"Non-irrigated Arable Land\": \"Low\",\n    \"Permanently Irrigated Land\": \"Very Low\",\n    \"Complex Cultivation Patterns\": \"Moderate\",\n    \"Land Principally Occupied by Agriculture with Significant Areas of Natural Vegetation\": \"Moderate-High\",\n    \"Sclerophyllous Vegetation\": \"High\",\n    \"Transitional Woodland-Shrub\": \"High\",\n    \"Natural Grasslands\": \"Low-Moderate\",\n    \"Broad-leaved Forests\": \"High\",\n    \"Mixed Forests\": \"High\",\n    \"Coniferous Forests\": \"Moderate-High\",\n    \"Peatbogs\": \"Very Low\",\n    \"Inland Marshes\": \"Very Low\",\n    \"Coastal Lagoons\": \"Very Low\",\n    \"Estuaries\": \"Very Low\",\n    \"Intertidal Flats\": \"Very Low\",\n    \"Water Courses\": \"Low-Moderate\",\n}\n\nsuitability_algirus = {\n    \"Discontinuous Urban Fabric\": \"Moderate\",\n    \"Continuous Urban Fabric\": \"Low\",\n    \"Industrial or Commercial Units\": \"Very Low\",\n    \"Airports\": \"Very Low\",\n    \"Port Areas\": \"Very Low\",\n    \"Sport and Leisure Facilities\": \"Very Low\",\n    \"Pastures\": \"High\",\n    \"Non-irrigated Arable Land\": \"High\",\n    \"Permanently Irrigated Land\": \"Low\",\n    \"Complex Cultivation Patterns\": \"High\",\n    \"Land Principally Occupied by Agriculture with Significant Areas of Natural Vegetation\": \"High\",\n    \"Sclerophyllous Vegetation\": \"High\",\n    \"Transitional Woodland-Shrub\": \"High\",\n    \"Natural Grasslands\": \"Moderate-High\",\n    \"Broad-leaved Forests\": \"Moderate\",\n    \"Mixed Forests\": \"Moderate\",\n    \"Coniferous Forests\": \"Low\",\n    \"Peatbogs\": \"Very Low\",\n    \"Inland Marshes\": \"Very Low\",\n    \"Coastal Lagoons\": \"Very Low\",\n    \"Estuaries\": \"Very Low\",\n    \"Intertidal Flats\": \"Very Low\",\n    \"Water Courses\": \"Low-Moderate\",\n}\n\ndataset_gpd[\"suitability_cuniculus\"] = dataset_gpd[\"dominant_land_cover_name\"].map(\n    suitability_cuniculus\n)\ndataset_gpd[\"suitability_quercinus\"] = dataset_gpd[\"dominant_land_cover_name\"].map(\n    suitability_quercinus\n)\ndataset_gpd[\"suitability_martes\"] = dataset_gpd[\"dominant_land_cover_name\"].map(\n    suitability_martes\n)\ndataset_gpd[\"suitability_algirus\"] = dataset_gpd[\"dominant_land_cover_name\"].map(\n    suitability_algirus\n)\n\n\nObserving the suitability assignment, there are some cells that have a land cover type that is not considered in the suitability mapping, resulting in NaN values for their suitability scores. These cells need to be handled appropriately before proceeding with further analysis. In this case, these cells will be dropped from the dataset to ensure that all remaining cells have valid suitability scores for all species.\n\ndataset_gpd[dataset_gpd[\"suitability_cuniculus\"].isnull()]\n\n\n\n\n\n\n\n\ngrid_id\ncell_area_km2\ndominant_land_cover_name\ncost_adaptation_atelerix\ncost_adaptation_martes\ncost_adaptation_eliomys\ncost_adaptation_oryctolagus\ncost_corridor\nhas_atelerix_algirus\nhas_martes_martes\nhas_eliomys_quercinus\nhas_oryctolagus_cuniculus\ngeometry\nsuitability_cuniculus\nsuitability_quercinus\nsuitability_martes\nsuitability_algirus\n\n\n\n\n510\ncell_26_39\n0.000360\nUnknown\n5.32\n5.50\n5.83\n8.41\n1.95\nFalse\nFalse\nFalse\nFalse\nMULTIPOLYGON (((4.02684 40.06534, 4.02693 40.0...\nNaN\nNaN\nNaN\nNaN\n\n\n630\ncell_31_43\n0.001558\nUnknown\n2.97\n4.19\n5.71\n7.16\n2.28\nFalse\nFalse\nFalse\nFalse\nPOLYGON ((4.07326 40.09201, 4.07318 40.09206, ...\nNaN\nNaN\nNaN\nNaN\n\n\n659\ncell_32_43\n0.059836\nUnknown\n4.83\n5.06\n4.60\n5.37\n1.23\nFalse\nFalse\nFalse\nFalse\nPOLYGON ((4.07337 40.09195, 4.07326 40.09201, ...\nNaN\nNaN\nNaN\nNaN\n\n\n750\ncell_35_38\n0.000178\nUnknown\n3.89\n6.36\n6.25\n6.04\n2.01\nFalse\nFalse\nFalse\nFalse\nPOLYGON ((4.09911 40.05792, 4.09911 40.05807, ...\nNaN\nNaN\nNaN\nNaN\n\n\n838\ncell_38_39\n0.002063\nUnknown\n6.18\n4.72\n3.23\n3.99\n2.98\nFalse\nFalse\nFalse\nFalse\nPOLYGON ((4.13082 40.06437, 4.1308 40.06439, 4...\nNaN\nNaN\nNaN\nNaN\n\n\n1116\ncell_47_32\n0.094412\nUnknown\n7.88\n3.41\n5.06\n4.81\n1.85\nFalse\nFalse\nFalse\nFalse\nMULTIPOLYGON (((4.20868 40.01629, 4.20876 40.0...\nNaN\nNaN\nNaN\nNaN\n\n\n1145\ncell_48_31\n0.001918\nUnknown\n5.02\n6.21\n6.69\n5.42\n2.38\nFalse\nFalse\nFalse\nFalse\nPOLYGON ((4.21266 40.01469, 4.21274 40.01469, ...\nNaN\nNaN\nNaN\nNaN\n\n\n1146\ncell_48_32\n0.000136\nUnknown\n3.68\n4.37\n6.10\n5.90\n1.48\nFalse\nFalse\nFalse\nFalse\nPOLYGON ((4.21272 40.01825, 4.21283 40.01813, ...\nNaN\nNaN\nNaN\nNaN\n\n\n\n\n\n\n\nFor the sustainability visualization, it is convenient to convert the categorical suitability scores into numerical values for easier mapping and visualization. The following mapping is used:\n\n\n\nSuitability Score\nNumerical Value\n\n\n\n\nVery Low\n1\n\n\nLow\n2\n\n\nLow-Moderate\n3\n\n\nModerate\n4\n\n\nModerate-High\n5\n\n\nHigh\n6\n\n\n\n\n\nCode\ndataset_gpd = dataset_gpd.dropna().copy()\n\nsuitability_to_num = {\n    \"Very Low\": 1,\n    \"Low\": 2,\n    \"Low-Moderate\": 3,\n    \"Moderate\": 4,\n    \"Moderate-High\": 5,\n    \"High\": 6,\n}\n\ndataset_gpd[\"suitability_cuniculus_num\"] = (\n    dataset_gpd[\"suitability_cuniculus\"].map(suitability_to_num).astype(\"int8\")\n)\ndataset_gpd[\"suitability_quercinus_num\"] = (\n    dataset_gpd[\"suitability_quercinus\"].map(suitability_to_num).astype(\"int8\")\n)\ndataset_gpd[\"suitability_martes_num\"] = (\n    dataset_gpd[\"suitability_martes\"].map(suitability_to_num).astype(\"int8\")\n)\ndataset_gpd[\"suitability_algirus_num\"] = (\n    dataset_gpd[\"suitability_algirus\"].map(suitability_to_num).astype(\"int8\")\n)\n\nsuitability_colors = {\n    1: \"red\",\n    2: \"orange\",\n    3: \"yellow\",\n    4: \"lightgreen\",\n    5: \"green\",\n    6: \"darkgreen\",\n}\n\n\ndef build_species_map(\n    gdf, value_col, species_label, center=(39.97, 4.0460), zoom=10, width=\"60%\"\n):\n    m = folium.Map(location=center, zoom_start=zoom, tiles=\"OpenStreetMap\", width=width)\n\n    for _, row in gdf.iterrows():\n        val = row[value_col]\n        color = suitability_colors.get(val, \"gray\")\n        land_cover_name = row[\"dominant_land_cover_name\"]\n\n        folium.GeoJson(\n            row.geometry,\n            style_function=lambda x, color=color: {\n                \"fillColor\": color,\n                \"color\": \"black\",\n                \"weight\": 0.5,\n                \"fillOpacity\": 0.7,\n            },\n            tooltip=(\n                f\"Grid ID: {row['grid_id']}&lt;br&gt;\"\n                f\"Dominant Land Cover: {land_cover_name}&lt;br&gt;\"\n                f\"Suitability ({species_label}): {val if pd.notna(val) else 'Unknown'}\"\n            ),\n        ).add_to(m)\n\n    return m\n\n\nmap_cuniculus = build_species_map(\n    dataset_gpd, \"suitability_cuniculus_num\", \"O. cuniculus\"\n)\nmap_quercinus = build_species_map(\n    dataset_gpd, \"suitability_quercinus_num\", \"E. quercinus\"\n)\nmap_martes = build_species_map(dataset_gpd, \"suitability_martes_num\", \"M. martes\")\nmap_algirus = build_species_map(dataset_gpd, \"suitability_algirus_num\", \"A. algirus\")\n\nmap_cuniculus\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nSuitability Maps for O. cuniculus\n\n\n\n\nCode\nmap_algirus\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nSuitability Maps for A. algirus\n\n\n\n\nCode\nmap_quercinus\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nSuitability Maps for E. quercinus\n\n\n\n\nCode\nmap_martes\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nSuitability Maps for M. martes\n\n\nVisually inspecting the maps, it can be noted a certain relation between the species with respect to the suitability scores. The Oryctolagus cuniculus and Atelerix algirus seem to have a similar distribution of suitability scores across the island, with many areas showing high suitability for both species. On the other hand, the Eliomys quercinus and Martes martes also exhibit a similar pattern to each other, but their suitability distributions differ from the first two species. This suggests that the habitat preferences of these species may overlap to some extent, but there are also distinct differences in their ecological requirements. An hypothesis could be that the Martes martes would have the same habitat preferences as the Eliomys quercinus due to their predator-prey relationship.\n\n\nBenefit Estimation\nIn order to estimate the benefit, is important to analyse the adaptation costs, while it is necessary to make a value in the same scale. So the first step is to observe the distribution of adaptation costs.\n\nadaptation_cost_columns = [\n    \"cost_adaptation_atelerix\",\n    \"cost_adaptation_martes\",\n    \"cost_adaptation_eliomys\",\n    \"cost_adaptation_oryctolagus\",\n]\ndataset_gpd[adaptation_cost_columns].hist(bins=50, figsize=(15, 10), grid=False)\npass\n\n\n\n\n\n\n\n\n\ncostes = dataset_gpd[dataset_gpd[\"cost_adaptation_oryctolagus\"] &lt; 30][\n    \"cost_adaptation_oryctolagus\"\n]\ncostes.hist(bins=100, figsize=(12, 8), grid=False)\npass\n\n\n\n\n\n\n\n\n\n\nCode\ncostes = dataset_gpd[adaptation_cost_columns].to_numpy().flatten()\n\n\nObserving the distibution plots, it seems that, for all the species, the costs follow a mixture of two distributions: a large number of low values and a small number of very high values. This suggests that most cells have relatively low adaptation costs, while a few cells are significantly more expensive to adapt. This pattern could reflect the varying suitability of different land types for each species, with some areas requiring minimal modifications and others needing substantial changes to become viable habitats.\nIt is also important to note that, the oryctolagus cuniculus, presents really high adaptation costs in comparison to the other species in some parcels.\nFor these reasons, the benefit, will be calculated as the suitability score multiplied by a cost multiplier based on the 75th percentile of adaptation costs, a value of 6.82. The goal is to get a good trade-off between suitability and cost, prioritizing areas that offer high suitability at a reasonable adaptation cost.\nHere is the table that shows the mapping from suitability scores to benefit multipliers:\n\n\n\nSuitability Score\nBenefit Multiplier\n\n\n\n\nVery Low\n0.1\n\n\nLow\n0.3\n\n\nLow-Moderate\n0.5\n\n\nModerate\n0.9\n\n\nModerate-High\n1.4\n\n\nHigh\n2\n\n\n\n\n\nCode\nsuitability_to_benefit = {\n    \"Very Low\": 0.1,\n    \"Low\": 0.3,\n    \"Low-Moderate\": 0.5,\n    \"Moderate\": 0.9,\n    \"Moderate-High\": 1.4,\n    \"High\": 2,\n}\n\nmultiplier = np.quantile(costes, 0.75)\n\n\ndataset_gpd[\"suitability_cuniculus_benefit\"] = dataset_gpd[\"suitability_cuniculus\"].map(\n    suitability_to_benefit\n)\ndataset_gpd[\"suitability_quercinus_benefit\"] = dataset_gpd[\"suitability_quercinus\"].map(\n    suitability_to_benefit\n)\ndataset_gpd[\"suitability_martes_benefit\"] = dataset_gpd[\"suitability_martes\"].map(\n    suitability_to_benefit\n)\ndataset_gpd[\"suitability_algirus_benefit\"] = dataset_gpd[\"suitability_algirus\"].map(\n    suitability_to_benefit\n)\n\ndataset_gpd[\"cuniculus_benefit\"] = (\n    dataset_gpd[\"suitability_cuniculus_benefit\"] * multiplier\n)\ndataset_gpd[\"quercinus_benefit\"] = (\n    dataset_gpd[\"suitability_quercinus_benefit\"] * multiplier\n)\ndataset_gpd[\"martes_benefit\"] = dataset_gpd[\"suitability_martes_benefit\"] * multiplier\ndataset_gpd[\"algirus_benefit\"] = dataset_gpd[\"suitability_algirus_benefit\"] * multiplier\ndataset_gpd.head()\n\n\n\n\n\n\n\n\n\ngrid_id\ncell_area_km2\ndominant_land_cover_name\ncost_adaptation_atelerix\ncost_adaptation_martes\ncost_adaptation_eliomys\ncost_adaptation_oryctolagus\ncost_corridor\nhas_atelerix_algirus\nhas_martes_martes\n...\nsuitability_martes_num\nsuitability_algirus_num\nsuitability_cuniculus_benefit\nsuitability_quercinus_benefit\nsuitability_martes_benefit\nsuitability_algirus_benefit\ncuniculus_benefit\nquercinus_benefit\nmartes_benefit\nalgirus_benefit\n\n\n\n\n0\ncell_0_28\n0.032397\nDiscontinuous Urban Fabric\n4.50\n6.37\n7.00\n6.34\n2.04\nFalse\nFalse\n...\n2\n4\n0.3\n0.3\n0.3\n0.9\n2.046\n2.046\n2.046\n6.138\n\n\n1\ncell_0_29\n0.257537\nDiscontinuous Urban Fabric\n3.86\n9.50\n7.25\n6.91\n1.90\nTrue\nFalse\n...\n2\n4\n0.3\n0.3\n0.3\n0.9\n2.046\n2.046\n2.046\n6.138\n\n\n2\ncell_0_30\n0.280383\nPastures\n2.39\n8.42\n8.93\n2.31\n2.35\nFalse\nFalse\n...\n2\n6\n2.0\n0.3\n0.3\n2.0\n13.640\n2.046\n2.046\n13.640\n\n\n3\ncell_0_31\n0.481008\nPastures\n2.91\n5.74\n8.85\n2.74\n2.23\nFalse\nFalse\n...\n2\n6\n2.0\n0.3\n0.3\n2.0\n13.640\n2.046\n2.046\n13.640\n\n\n4\ncell_0_32\n0.040811\nPastures\n1.86\n7.13\n10.03\n2.06\n0.88\nFalse\nFalse\n...\n2\n6\n2.0\n0.3\n0.3\n2.0\n13.640\n2.046\n2.046\n13.640\n\n\n\n\n5 rows × 29 columns",
    "crumbs": [
      "Article",
      "Exploratory Data Analysis"
    ]
  },
  {
    "objectID": "src/sections/introduction.html",
    "href": "src/sections/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Menorca, designated as a UNESCO Biosphere Reserve, represents a unique ecological mosaic where biodiversity coexists with centuries of human activity [1]. However, like many island ecosystems, it faces the growing challenge of habitat fragmentation driven by anthropogenic pressures such as agricultural intensification and urbanization. Fragmentation reduces the viability of species by isolating populations, limiting gene flow and restricting access to scattered resources [2].\nTo mitigate these adverse effects, establishing a well-connected network of wildlife corridors is widely advocated as a practical conservation strategy [3]. Such networks facilitate species movement and metapopulation interactions, helping to sustain essential ecosystem functions [4]. The design of an efficient corridor system requires balancing ecological integrity with economic costs, transforming the conservation challenge into an optimization problem where every decision variable must maximize biological utility within a finite budget [5].\nWildlife corridor design has evolved from heuristic methods to formal optimization. Early approaches modeled connectivity as a Network Steiner Tree (NST) [6]. Subsequent research formalized the connected subgraph problem, maximizing biological utility under budget constraints [7], [8]. Recent Mixed-Integer Linear Programming (MILP) models have advanced this field by incorporating network flows and specific spatial attributes like corridor width and length. [2], [5].\nThis study addresses the optimal configuration of wildlife corridors and the strategic adaptation of habitat patches for four distinct species with varying requirements: the North African hedgehog (Atelerix algirus), the European pine marten (Martes martes), the Garden Dormouse (Eliomys quercinus), and the European rabbit (Oryctolagus cuniculus) [9], [10], [11], [12]. In this web-based document, we present a Multi-objective MILP model applied to the discretized landscape of Menorca. Unlike formulations requiring a single connected component linking all colonies, our approach optimizes the selection of corridors and habitat adaptations subject to strict budget constraints by prioritizing critical sub-networks and habitat expansions, ensuring high-value conservation outcomes even when total island-wide connectivity is resource-prohibitive.\n\n\n\n\nReferences\n\n[1] Comunidad Autónoma de las Illes Balears, “Ley 3/2023, de 17 de febrero, de Menorca reserva de biosfera.” Boletín Oficial del Estado, n.º 137, pp. 82079–82141, 2023. Available: https://www.boe.es/eli/es-ib/l/2023/02/17/3\n\n\n[2] Y. Wang, P. Qin, and H. Önal, “An optimisation approach for designing wildlife corridors with ecological and spatial considerations,” Methods in Ecology and Evolution, vol. 13, no. 5, pp. 1042–1051, 2022, doi: https://doi.org/10.1111/2041-210X.13817.\n\n\n[3] D. B. Lindenmayer and H. A. Nix, “Ecological principles for the design of wildlife corridors,” Conservation Biology, vol. 7, no. 3, pp. 627–630, 1993, Accessed: Nov. 22, 2025. [Online]. Available: http://www.jstor.org/stable/2386693\n\n\n[4] S. Díaz et al., “Summary for policymakers of the global assessment report on biodiversity and ecosystem services of the intergovernmental science-policy platform on biodiversity and ecosystem services.” Available: https://uwe-repository.worktribe.com/output/1493508\n\n\n[5] Y. Wang, P. Qin, S. Li, and H. Önal, “Optimal configuration of a wildlife corridor system,” Global Ecology and Conservation, vol. 46, p. e02560, 2023, doi: https://doi.org/10.1016/j.gecco.2023.e02560.\n\n\n[6] J. C. Williams, “Delineating protected wildlife corridors with multi‐objective programming,” Environmental Modeling & Assessment, vol. 3, no. 1, pp. 77–86, Mar. 1998, doi: 10.1023/A:1019006721277.\n\n\n[7] J. M. Conrad, C. P. Gomes, W.-J. van Hoeve, A. Sabharwal, and J. F. Suter, “Wildlife corridors as a connected subgraph problem,” Journal of Environmental Economics and Management, vol. 63, no. 1, pp. 1–18, 2012, doi: https://doi.org/10.1016/j.jeem.2011.08.001.\n\n\n[8] D. Yemshanov et al., “Prioritizing restoration of fragmented landscapes for wildlife conservation: A graph-theoretic approach,” Biological Conservation, vol. 232, pp. 173–186, 2019, doi: https://doi.org/10.1016/j.biocon.2019.02.003.\n\n\n[9] W. contributors, “European pine marten.” https://en.wikipedia.org/wiki/European_pine_marten, 2025.\n\n\n[10] W. contributors, “European rabbit.” https://en.wikipedia.org/wiki/European_rabbit, 2025.\n\n\n[11] W. contributors, “Garden dormouse.” https://en.wikipedia.org/wiki/Garden_dormouse, 2025.\n\n\n[12] W. contributors, “North african hedgehog.” https://en.wikipedia.org/wiki/North_African_hedgehog, 2025.",
    "crumbs": [
      "Article",
      "Introduction"
    ]
  },
  {
    "objectID": "src/sections/experiments.html",
    "href": "src/sections/experiments.html",
    "title": "Experimentation",
    "section": "",
    "text": "In this section, we present the experimental results obtained from the proposed optimization framework. The experimentation is structured into two distinct phases. First, we conduct a comparative performance analysis of four different solvers using the distilled model described in Graph-Based Corridor Model. Second, utilizing the best-performing solver, we execute the full MILP model Integer Linear Programming Model with \\(\\alpha = 0.5\\) value to observe the full model trade-off performance.\nThe experimental framework was implemented in Python. We utilized the Google OR-Tools library [1] to access the open-source solvers CBC [2] and SCIP [3], as well as Google’s native CP-SAT solver [4]. Additionally, the commercial solver Gurobi [5] was integrated into the pipeline. All experiments were conducted on a workstation with an AMD Ryzen 5 7600X processor (6 cores, 4.70 GHz) and 32 GB of DDR5 RAM.",
    "crumbs": [
      "Article",
      "Experimentation"
    ]
  },
  {
    "objectID": "src/sections/experiments.html#environment-setup-and-configuration",
    "href": "src/sections/experiments.html#environment-setup-and-configuration",
    "title": "Experimentation",
    "section": "Environment Setup and Configuration",
    "text": "Environment Setup and Configuration\nFirst, we establish our working environment. This includes importing necessary libraries for data manipulation, visualization, and statistical analysis. We also configure the plotting aesthetics to ensure our visualizations are clear and professional.\n\n\nCode\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport scikit_posthocs as sp\n\nfrom scipy import stats\nfrom pyfonts import load_google_font\nfrom matplotlib import rcParams\nfrom matplotlib.font_manager import fontManager\n\nfont = load_google_font(\"Courier Prime\", weight=\"regular\", italic=False)\nfontManager.addfont(str(font.get_file()))\nrcParams.update(\n    {\n        \"font.family\": font.get_name(),\n        \"font.style\": font.get_style(),\n        \"font.weight\": font.get_weight(),\n        \"font.size\": font.get_size(),\n        \"font.stretch\": font.get_stretch(),\n        \"font.variant\": font.get_variant(),\n        \"axes.titlesize\": 16,\n        \"axes.labelsize\": 14,\n        \"xtick.labelsize\": 14,\n        \"ytick.labelsize\": 14,\n        \"legend.fontsize\": 16,\n        \"figure.titlesize\": 36,\n    }\n)",
    "crumbs": [
      "Article",
      "Experimentation"
    ]
  },
  {
    "objectID": "src/sections/experiments.html#data-preparation",
    "href": "src/sections/experiments.html#data-preparation",
    "title": "Experimentation",
    "section": "Data Preparation",
    "text": "Data Preparation\nNext, we load the experimental results. The data is formatted to facilitate analysis.\n\n\nCode\nexp = pd.read_csv(\"../../data/experiments/graph_model_solver_experiment.csv\")\n\nexp = exp.rename(\n    columns={\n        \"TIEMPO\": \"TIME\",\n        \"FASE\": \"PHASE\"\n    }\n)\n\nexp[\"PHASE\"] = exp[\"PHASE\"].str.replace(\"fase\", \"phase\")\n\nexp = exp.pivot_table(\n    index=[\"SOLVER\", \"RUN\"],\n    columns=\"PHASE\",\n    values=[\"TIME\"]\n).reset_index()\n\nexp.columns = [col[1] if col[1] else col[0] for col in exp.columns]\n\nphases = [col for col in exp.columns if \"phase\" in str(col)]\nexp[\"total\"] = exp[phases].sum(axis=1)\nexp[\"SOLVER\"] = exp[\"SOLVER\"].str.upper()\n\nexp\n\n\n\n\n\n\n\n\n\nSOLVER\nRUN\nphase1\nphase2\nphase3\ntotal\n\n\n\n\n0\nCBC\n1\n0.037\n0.003\n0.027\n0.067\n\n\n1\nCBC\n2\n0.036\n0.002\n0.026\n0.064\n\n\n2\nCBC\n3\n0.036\n0.002\n0.026\n0.064\n\n\n3\nCBC\n4\n0.036\n0.002\n0.026\n0.064\n\n\n4\nCBC\n5\n0.036\n0.002\n0.026\n0.064\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n195\nSCIP\n46\n0.024\n0.009\n0.046\n0.079\n\n\n196\nSCIP\n47\n0.028\n0.009\n0.049\n0.086\n\n\n197\nSCIP\n48\n0.025\n0.009\n0.048\n0.082\n\n\n198\nSCIP\n49\n0.028\n0.009\n0.049\n0.086\n\n\n199\nSCIP\n50\n0.028\n0.009\n0.048\n0.085\n\n\n\n\n200 rows × 6 columns",
    "crumbs": [
      "Article",
      "Experimentation"
    ]
  },
  {
    "objectID": "src/sections/experiments.html#visualization",
    "href": "src/sections/experiments.html#visualization",
    "title": "Experimentation",
    "section": "Visualization",
    "text": "Visualization\nTo understand the performance of different solvers across various phases, we create visualizations that combine strip plots and box plots. This allows us to see both the distribution of individual data points and summary statistics.\nFirst, we can observe performance differences between the solvers across all phases and in total. Second, the points within each solver are tighly clustered, suggesting low variation in performance across runs. Finally, a visual inspection suggests that data may not be normally distributed and variances may differ between solvers, which we will formally test in the next section.\n\n\nCode\n# Define a color palette\npalette = [\n    \"#009d9a\",  # cbc\n    \"#002d9c\", # gurobi\n    \"#a56eff\", # sat\n    \"#9f1853\", # scip\n]\n\n# Number of phases + total\ntargets = phases + ['total']\n\nnum_caption = [\"(a)\", \"(b)\", \"(c)\"]\n\n# get global max for y-axis, excluding total column\ny_max = exp[phases].max().max() * 1.1  #\n\n# Create plots for each target\nfor i, target in enumerate(targets):\n    # Create figure and axis\n    fig, ax = plt.subplots(figsize=(6, 6))\n\n    # Plot stripplot\n    sns.stripplot(\n        data=exp, # dataset\n        x=\"SOLVER\", # x-axis\n        y=target, # y-axis (time)\n        hue=\"SOLVER\",\n        legend=False,\n        ax=ax,\n        alpha=0.8, # point transparency\n        # useful when there are many overlapping points\n        jitter=True,\n        size=6, # point size\n        palette=palette, # color palette\n        zorder=0 # draw below the boxplot\n    )\n\n    # Plot boxplot\n    sns.boxplot(\n        data=exp,\n        x=\"SOLVER\",\n        y=target,\n        ax=ax,\n        # Outliers already shown in stripplot\n        showfliers=False,\n        boxprops={\n            'facecolor':'none', # transparent box, better visibility of stripplot\n            'edgecolor':'black', # black border\n            'linewidth': 1.25\n        },\n        # consistent color for whiskers\n        whiskerprops={\n            'color':'black',\n            'linewidth': 1.25\n        },\n        # consistent color for caps\n        capprops={\n            'color':'black',\n            'linewidth': 1.25\n        },\n        # consistent color for medians\n        medianprops={\n            'color':'black',\n            'linewidth': 1.25\n        },\n        width=0.8,\n        zorder=1 # draw above the stripplot\n    )\n\n    # Customize plot\n    if target == 'total':\n        ax.set_title(\"Total Time\", pad=15)\n        ax.set_xlabel(\"\")\n\n    else:\n        ax.set_title(f\"{target[:-1].capitalize()} {target[-1]}\", pad=15)\n        ax.set_ylim(0, y_max)\n\n    ax.set_ylabel(\"Time (s)\")\n\n    # Professional look\n    ax.grid(True, which='major', linestyle='-', linewidth=0.75, alpha=0.2)\n    ax.minorticks_on()\n    ax.grid(True, which='minor', linestyle='-', linewidth=0.25, alpha=0.10)\n    ax.set_axisbelow(True)\n\n    # Save figures readily for report\n    filename = f\"../../data/figures/plot_{target}.pdf\"\n    plt.savefig(filename, format='pdf', bbox_inches='tight', dpi=300)",
    "crumbs": [
      "Article",
      "Experimentation"
    ]
  },
  {
    "objectID": "src/sections/experiments.html#statistical-analysis",
    "href": "src/sections/experiments.html#statistical-analysis",
    "title": "Experimentation",
    "section": "Statistical Analysis",
    "text": "Statistical Analysis\n\nAssumtions Checking\nAs a prerequisite for many statistical tests, we need to verify if our data meets certain assumptions, specifically normality and homogeneity of variances in onder to choose the appropriate statistical tests. If these assumptions are violated, we will proceed with non-parametric tests.\n\nNormality: To determine if the solver times follow a normal distribution, we used the Shapiro-Wilk test [6]. The test statistic \\(W\\) is defined as:\n\n\\[\nW = \\frac{(\\sum_{i=1}^{n} a_i x_{(i)})^2}{\\sum_{i=1}^{n} (x_i - \\bar{x})^2}\n\\]\nWhere \\(x_{(i)}\\) are the ordered sample values and \\(a_i\\) are constants generated from the means and covariances of the order statistics.\n\n\\(H_0\\): The population is normally distributed.\n\\(H_1\\): The population is not normally distributed.\n\nWe reject \\(H_0\\) if \\(p &lt; 0.05\\)\nAs seen in the output, the p-values for all solvers across all phases are significantly below 0.05 (e.g., \\(p \\approx 0.000\\)). This indicates that the data is not normally distributed.\n\nHomogeneity of Variance: To verify if the variances are equal across different solvers (homoscedasticity), we applied Levene’s test [7]. The test statistic \\(W\\) is calculated as:\n\n\\[\nW = \\frac{(N-k)}{(k-1)} \\frac{\\sum_{i=1}^{k} N_i (Z_{i\\cdot} - Z_{\\cdot\\cdot})^2}{\\sum_{i=1}^{k} \\sum_{j=1}^{N_i} (Z_{ij} - Z_{i\\cdot})^2}\n\\]\nWhere \\(k\\) is the number of groups (solvers), \\(N\\) is the total sample size, and \\(Z_{ij} = |Y_{ij} - \\tilde{Y}_{i\\cdot}|\\) (absolute deviation from the group median).\n\n\\(H_0\\): The population variances are equal (\\(\\sigma^2_1 = \\sigma^2_2 = \\dots = \\sigma^2_k\\)).\n\\(H_1\\): At least one variance is different.\n\nWe reject \\(H_0\\) if \\(p &lt; 0.05\\)\nWe checked if the variances were equal across groups. With the exception of Phase 3, the p-values were below 0.05, indicating heteroscedasticity (unequal variances).\n\nfor target in targets:\n    print(f\"--- Assumptions for {target} ---\")\n\n    # check normality (Shapiro-Wilk)\n    # check p-value. If p &lt; 0.05, we reject normality\n    for solver in exp[\"SOLVER\"].unique():\n        stat, p = stats.shapiro(exp[exp[\"SOLVER\"] == solver][target])\n        print(f\"Shapiro ({solver}): p={p:.6f}\")\n\n    # check homogeneity of variance (Levene)\n    # If p &lt; 0.05, variances are different.\n    solvers_data = [group[target].values for name, group in exp.groupby(\"SOLVER\")]\n    stat, p_levene = stats.levene(*solvers_data)\n    print(f\"Levene Test: p={p_levene:.6f}\\n\")\n\n--- Assumptions for phase1 ---\nShapiro (CBC): p=0.000000\nShapiro (GUROBI): p=0.000000\nShapiro (SAT): p=0.000038\nShapiro (SCIP): p=0.000000\nLevene Test: p=0.000000\n\n--- Assumptions for phase2 ---\nShapiro (CBC): p=0.000000\nShapiro (GUROBI): p=0.000000\nShapiro (SAT): p=0.000000\nShapiro (SCIP): p=0.000000\nLevene Test: p=0.000067\n\n--- Assumptions for phase3 ---\nShapiro (CBC): p=0.000000\nShapiro (GUROBI): p=0.001758\nShapiro (SAT): p=0.000000\nShapiro (SCIP): p=0.000000\nLevene Test: p=0.569665\n\n--- Assumptions for total ---\nShapiro (CBC): p=0.000000\nShapiro (GUROBI): p=0.000000\nShapiro (SAT): p=0.000000\nShapiro (SCIP): p=0.000000\nLevene Test: p=0.001094\n\n\n\n\n\nKruskal-Wallis Test\nAs the assumptions for ANOVA [8] were not met, we proceed with the Kruskal-Wallis H-test [9], a non-parametric alternative that does not assume normality or homogeneity of variances. This test will help us determine if there are statistically significant differences between the solvers for each target metric. The \\(H\\) statistic is given by:\n\\[\nH = \\frac{12}{N(N+1)} \\sum_{i=1}^{k} \\frac{R_i^2}{n_i} - 3(N+1)\n\\]\nWhere \\(R_i\\) is the sum of ranks for group \\(i\\), and \\(n_i\\) is the number of observations in group \\(i\\).\n\n\\(H_0\\): The population medians of all groups are equal.\n\\(H_1\\): At least one population median is different from the others.\n\nWe reject \\(H_0\\) if \\(p &lt; 0.05\\)\nThe results yielded extremely low p-values (\\(p &lt; 10^{-37}\\)) for all phases and the total time. This allows us to reject the null hypothesis and confirm that there are significant statistical differences in performance between the solvers in every phase of the experiment.\n\nprint(\"### Kruskal-Wallis H-Test Results ###\")\n\nsignificant_targets = []\n\nfor target in targets:\n    # Group data by solver\n    groups = [group[target].values for name, group in exp.groupby(\"SOLVER\")]\n\n    # Perform Kruskal-Wallis\n    stat, p_value = stats.kruskal(*groups)\n\n    print(f\"{target.upper()} | Statistic: {stat:.2f}, p-value: {p_value:.2e}\")\n\n    if p_value &lt; 0.05:\n        print(f\"Significant differences found in {target}.\")\n        significant_targets.append(target)\n    else:\n        print(f\"No significant differences in {target}.\")\n    print(\"-\" * 30)\n\n### Kruskal-Wallis H-Test Results ###\nPHASE1 | Statistic: 162.31, p-value: 5.82e-35\nSignificant differences found in phase1.\n------------------------------\nPHASE2 | Statistic: 188.32, p-value: 1.41e-40\nSignificant differences found in phase2.\n------------------------------\nPHASE3 | Statistic: 182.71, p-value: 2.29e-39\nSignificant differences found in phase3.\n------------------------------\nTOTAL | Statistic: 181.76, p-value: 3.68e-39\nSignificant differences found in total.\n------------------------------\n\n\n\n\nPost-hoc Analysis\nHaving established that significant differences exist among the solvers, we now conduct a post-hoc analysis using Dunn’s test [10]. This test allows us to perform pairwise comparisons between the solvers to identify which specific pairs differ significantly. The \\(z\\)-test statistic for comparing group \\(i\\) and group \\(j\\) is:\n\\[\nz_{ij} = \\frac{\\bar{R}_i - \\bar{R}_j}{\\sqrt{\\frac{N(N+1)}{12} \\left( \\frac{1}{n_i} + \\frac{1}{n_j} \\right)}}\n\\]\nWhere \\(\\bar{R}\\) represents the mean rank of the group. To control for the family-wise error rate due to multiple comparisons, we applied the Bonferroni correction:\n\\[\n\\alpha_{adjusted} = \\frac{\\alpha}{m}\n\\]\nWhere \\(m\\) is the number of pairwise comparisons\n\n\\(H_0\\): There is no difference between the two groups.\n\\(H_1\\): There is a difference between the two groups.\n\nWe reject \\(H_0\\) if \\(p &lt; \\alpha_{adjusted}\\)\nThe resulting matrices of p-values reveal the following:\n\nPhase 1: hile most solvers differ significantly, CBC and SAT show no statistically significant difference (\\(p=1.0\\)).\nPhases 2 and 3: In these phases, all pairwise comparisons yield \\(p &lt; 0.05\\), suggesting distinct performance profiles for each solver.\nTotal: The aggregated view confirms that globally, the solvers have significantly different performance characteristics, with the lowest p-values found when comparing GUROBI and SCIP against the others.\n\n\nif significant_targets:\n    print(\"### Post-hoc Analysis (Dunn's Test) ###\")\n\n    for target in significant_targets:\n        print(f\"\\n--- Pairwise comparisons for {target} ---\")\n\n        # Dunn's test\n        # p_adjust='bonferroni' corrects for doing multiple tests to avoid False Positives\n        dunn_results = sp.posthoc_dunn(exp, val_col=target, group_col='SOLVER', p_adjust='bonferroni')\n\n        print(dunn_results)\n\n### Post-hoc Analysis (Dunn's Test) ###\n\n--- Pairwise comparisons for phase1 ---\n                 CBC        GUROBI           SAT          SCIP\nCBC     1.000000e+00  2.325443e-25  1.000000e+00  2.079205e-08\nGUROBI  2.325443e-25  1.000000e+00  1.170744e-26  1.829275e-05\nSAT     1.000000e+00  1.170744e-26  1.000000e+00  3.738267e-09\nSCIP    2.079205e-08  1.829275e-05  3.738267e-09  1.000000e+00\n\n--- Pairwise comparisons for phase2 ---\n                 CBC        GUROBI           SAT          SCIP\nCBC     1.000000e+00  7.089410e-06  2.393183e-03  2.689430e-16\nGUROBI  7.089410e-06  1.000000e+00  2.689430e-16  2.425579e-39\nSAT     2.393183e-03  2.689430e-16  1.000000e+00  7.089410e-06\nSCIP    2.689430e-16  2.425579e-39  7.089410e-06  1.000000e+00\n\n--- Pairwise comparisons for phase3 ---\n                 CBC        GUROBI           SAT          SCIP\nCBC     1.000000e+00  2.302696e-17  1.815192e-04  1.815192e-04\nGUROBI  2.302696e-17  1.000000e+00  3.854149e-05  4.834477e-37\nSAT     1.815192e-04  3.854149e-05  1.000000e+00  4.341926e-16\nSCIP    1.815192e-04  4.834477e-37  4.341926e-16  1.000000e+00\n\n--- Pairwise comparisons for total ---\n                 CBC        GUROBI           SAT          SCIP\nCBC     1.000000e+00  2.907454e-17  1.912595e-04  1.869560e-04\nGUROBI  2.907454e-17  1.000000e+00  4.128985e-05  7.430566e-37\nSAT     1.912595e-04  4.128985e-05  1.000000e+00  5.083186e-16\nSCIP    1.869560e-04  7.430566e-37  5.083186e-16  1.000000e+00\n\n\nNow, we generate the map for the best solver found in the experiments (Gurobi) using the full MILP model with \\(\\alpha = 0.5\\)\n\n\nCode\nfrom pathlib import Path\nimport sys\nimport geopandas as gpd\nfrom folium.plugins import Fullscreen\n\n# Navigate to the src directory which contains the models package\nsrc_path = Path(__file__).parent.parent if \"__file__\" in dir() else Path(\".\").resolve().parent\nif str(src_path) not in sys.path:\n    sys.path.insert(0, str(src_path))\n\n# Alternative: if running from the document directory, try multiple paths\nfor potential_path in [Path(\".\").parent, Path(\".\").parent.parent, Path(\"..\"), Path(\"../src\")]:\n    resolved = potential_path.resolve()\n    if (resolved / \"models\").exists() and str(resolved) not in sys.path:\n        sys.path.insert(0, str(resolved))\n        break\n\nfrom models.visualization import load_solution_summary, create_solution_pdf\n\ngdf = gpd.read_parquet(\"../../data/processed_dataset.parquet\")\n\nsummary = load_solution_summary(\n    \"../../data/experiments/summaries/modelling_multi_species_alpha_0.5_summary.json\"\n)\n\ncreate_solution_pdf(\n    gdf,\n    summary,\n    output_path=\"../../data/figures/solution_map_gurobi_alpha_0.5.pdf\",\n    save=False\n)",
    "crumbs": [
      "Article",
      "Experimentation"
    ]
  },
  {
    "objectID": "src/index.html",
    "href": "src/index.html",
    "title": "Mixed-Integer Linear Programming for Habitat Management and Ecological Connectivity in Mediterranean Landscapes",
    "section": "",
    "text": "Note\n\n\n\nThis web-based document serves as a guide and supplementary material to the paper attached to the assignment.\n\n\nContents\n\nIntroduction\nExploratory Data Analysis\nInteger Linear Programming Model\nGraph-Based Corridor Model\nExperiments\n\nCode: link",
    "crumbs": [
      "Mixed-Integer Linear Programming for Habitat Management and Ecological Connectivity in Mediterranean Landscapes"
    ]
  },
  {
    "objectID": "src/sections/graph_model_budgeted.html",
    "href": "src/sections/graph_model_budgeted.html",
    "title": "Graph-Based Budgeted Corridor Model",
    "section": "",
    "text": "The graph-based models in graph_core.py, graph_model_gurobi_budgeted.py, and graph_model_ortools_budgeted.py are lightweight adaptations of the full multi-species ILP. Instead of optimizing over every cell and flow variable, they precompute a manageable set of shortest-path candidates and solve smaller budgeted selection problems. This keeps experiments tractable while following the three-phase algorithm shown in the report (prey → predator → rehabilitation).\n\n\n\nGraph construction (MenorcaEcologicalCorridor): Loads grid_id geometry plus per-cell corridor cost into a directed networkx.DiGraph. Nodes carry the construction cost; edges are added for touching neighbors supplied by adjacency, associating the cost of the incoming node to the edge. build_graph can drop excluded cells (e.g., prey paths when routing the predator) before Dijkstra is run.\nPath candidate enumeration: generate_pairs limits origin pairs by Manhattan distance (MAX_DISTANCE_METHOD). enumerate_candidates calls Dijkstra per species/origin pair to build PathCandidate objects (path id, species, origin/destination, cell list, cost, length). Reverse indexes origin_to_paths and cell_to_paths capture coverage and sharing relationships used by the optimization.\nDecision variables and constraints (path selection phase):\n\nBinary z_path per candidate path.\nOptional binary c_species_origin to mark a covered origin (created when penalties or minimum coverage are active).\nOrigin coverage: either sum z &gt;= 1 per origin, or sum z &gt;= c plus uncovered-origin penalty and/or minimum coverage fraction.\nPer-species corridor budget: sum(cost_path * z_path) &lt;= budget_species.\nObjective: minimize total selected path cost plus optional penalties.\n\nDecision variables and constraints (rehabilitation phase):\n\nBinary rehab_species_cell only on candidates adjacent to a selected corridor or origin, filtered by _cell_allowed_for_species to enforce predator–prey incompatibility up front.\nObjective: minimize \\(\\alpha\\)·(adaptation cost) − (1−\\(\\alpha\\))·(benefit).\nCompatibility cap: weighted sum per cell ≤ 2, blocking predator with prey rehab in the same location.\nPer-species adaptation budget: sum(cost * rehab) &lt;= budget_species.\n\nBudget handling: _validate_and_prepare_budget_shares converts total budget and per-species percentages into corridor and adaptation caps, mirroring the full ILP while keeping shares configurable.\nDual solver backends: solve_path_selection / solve_rehab implement the ILPs with Gurobi; solve_path_selection_ortools / solve_rehabilitation_ortools mirror the same structure with OR-Tools/SCIP so experiments can run without a commercial solver.",
    "crumbs": [
      "Article",
      "Graph-Based Budgeted Corridor Model"
    ]
  },
  {
    "objectID": "src/sections/graph_model_budgeted.html#rationale",
    "href": "src/sections/graph_model_budgeted.html#rationale",
    "title": "Graph-Based Budgeted Corridor Model",
    "section": "",
    "text": "The graph-based models in graph_core.py, graph_model_gurobi_budgeted.py, and graph_model_ortools_budgeted.py are lightweight adaptations of the full multi-species ILP. Instead of optimizing over every cell and flow variable, they precompute a manageable set of shortest-path candidates and solve smaller budgeted selection problems. This keeps experiments tractable while following the three-phase algorithm shown in the report (prey → predator → rehabilitation).\n\n\n\nGraph construction (MenorcaEcologicalCorridor): Loads grid_id geometry plus per-cell corridor cost into a directed networkx.DiGraph. Nodes carry the construction cost; edges are added for touching neighbors supplied by adjacency, associating the cost of the incoming node to the edge. build_graph can drop excluded cells (e.g., prey paths when routing the predator) before Dijkstra is run.\nPath candidate enumeration: generate_pairs limits origin pairs by Manhattan distance (MAX_DISTANCE_METHOD). enumerate_candidates calls Dijkstra per species/origin pair to build PathCandidate objects (path id, species, origin/destination, cell list, cost, length). Reverse indexes origin_to_paths and cell_to_paths capture coverage and sharing relationships used by the optimization.\nDecision variables and constraints (path selection phase):\n\nBinary z_path per candidate path.\nOptional binary c_species_origin to mark a covered origin (created when penalties or minimum coverage are active).\nOrigin coverage: either sum z &gt;= 1 per origin, or sum z &gt;= c plus uncovered-origin penalty and/or minimum coverage fraction.\nPer-species corridor budget: sum(cost_path * z_path) &lt;= budget_species.\nObjective: minimize total selected path cost plus optional penalties.\n\nDecision variables and constraints (rehabilitation phase):\n\nBinary rehab_species_cell only on candidates adjacent to a selected corridor or origin, filtered by _cell_allowed_for_species to enforce predator–prey incompatibility up front.\nObjective: minimize \\(\\alpha\\)·(adaptation cost) − (1−\\(\\alpha\\))·(benefit).\nCompatibility cap: weighted sum per cell ≤ 2, blocking predator with prey rehab in the same location.\nPer-species adaptation budget: sum(cost * rehab) &lt;= budget_species.\n\nBudget handling: _validate_and_prepare_budget_shares converts total budget and per-species percentages into corridor and adaptation caps, mirroring the full ILP while keeping shares configurable.\nDual solver backends: solve_path_selection / solve_rehab implement the ILPs with Gurobi; solve_path_selection_ortools / solve_rehabilitation_ortools mirror the same structure with OR-Tools/SCIP so experiments can run without a commercial solver.",
    "crumbs": [
      "Article",
      "Graph-Based Budgeted Corridor Model"
    ]
  },
  {
    "objectID": "src/sections/graph_model_budgeted.html#pipeline",
    "href": "src/sections/graph_model_budgeted.html#pipeline",
    "title": "Graph-Based Budgeted Corridor Model",
    "section": "Pipeline",
    "text": "Pipeline\n\nPhase 1: Non-Conflicting Species (Prey)\nInput: Full landscape graph \\(G\\), species set \\(S_{prey} = S \\setminus \\{\\text{Martes}\\}\\).\nProcess: 1. Generate origin pairs \\((r_i, r_j)\\) for each prey species where \\(\\text{manhattan}(r_i, r_j) \\leq D_{max}\\). 2. Compute shortest path for each pair using Dijkstra’s algorithm. 3. Create PathCandidate objects with path cells and costs. 4. Solve path selection ILP:\n\\(\\min \\sum_{p \\in P} \\text{cost}_p \\cdot z_p\\)\nSubject to: - Each origin participates in at least one selected path. - Per-species budget constraints.\nOutput: Selected paths for prey species, cells used.\n\n\nPhase 2: Conflicting Species (Predator)\nInput: Graph \\(G'\\) with incompatible cells removed.\nIncompatible cells (removed from \\(G'\\)): - Origin cells of Oryctolagus and Eliomys unless origins. - Interior cells of paths selected in Phase 1 for Oryctolagus and Eliomys.\nProcess: Same as Phase 1, but only for Martes martes.\nOutput: Selected paths for Martes.\n\n\nPhase 3: Rehabilitation\nInput: Fixed corridor network from Phases 1 & 2.\nCandidate cells: Cells adjacent to built corridors or origins.\nObjective: \\(\\min \\alpha \\sum_{s,j} a_{sj} R_{sj} - (1-\\alpha) \\sum_{s,j} b_{sj} R_{sj}\\).\nConstraints: - Compatibility: \\(2R_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\leq 2\\). - Per-species adaptation budgets.\n\n\nPhase 4 — Summary and maps\n\nbuild_summary_from_paths consolidates corridors, rehabilitated cells, origin sets, and colors into a SolutionSummary.\nMaps and JSON summaries are exported: maps/graph_model_*_budgeted_map_*.html and data/experiments/summaries/graph_model_*_budgeted_summary.json.",
    "crumbs": [
      "Article",
      "Graph-Based Budgeted Corridor Model"
    ]
  },
  {
    "objectID": "src/sections/graph_model_budgeted.html#data-and-parameters",
    "href": "src/sections/graph_model_budgeted.html#data-and-parameters",
    "title": "Graph-Based Budgeted Corridor Model",
    "section": "Data and parameters",
    "text": "Data and parameters\n\nInput: data/processed_dataset.parquet providing grid_id, geometry, corridor costs, adaptation costs, adaptation benefits, and per-species presence flags.\nShares: CORRIDOR_SHARE_BY_SPECIES and ADAPTATION_SHARE_BY_SPECIES (default 500 total budget) distribute spending by extinction risk.\nDistance filter: MAX_DISTANCE_METHOD limits origin pairs to keep the candidate set small and runtimes short.\nOptional coverage controls: uncovered-origin penalty and minimum coverage fraction can be toggled per experiment.",
    "crumbs": [
      "Article",
      "Graph-Based Budgeted Corridor Model"
    ]
  },
  {
    "objectID": "src/sections/graph_model_budgeted.html#running-the-pipelines",
    "href": "src/sections/graph_model_budgeted.html#running-the-pipelines",
    "title": "Graph-Based Budgeted Corridor Model",
    "section": "Running the pipelines",
    "text": "Running the pipelines\nUse any solver; both follow the same four-phase flow described above.\nHere are example commands to run either the Gurobi-backed or OR-Tools-backed pipeline in bash (first one) or python (second one):\n# Gurobi-backed pipeline\nuv run python src/models/graph_model_gurobi_budgeted.py\n\n# OR-Tools-backed pipeline (SCIP)\nuv run python src/models/graph_model_ortools_budgeted.py\n\nfrom models.graph_model_gurobi_budgeted import run_pipeline as run_gurobi\nfrom models.graph_model_ortools_budgeted import run_pipeline as run_ortools\n\nrun_gurobi()\nrun_ortools()\n\nThis graph-based family preserves the ecological logic of the full multi-species ILP while reducing problem size: shortest-path enumeration contains the combinatorial explosion, per-phase filtering enforces predator–prey separation, and budgeted subproblems can be solved quickly for repeated experiments.",
    "crumbs": [
      "Article",
      "Graph-Based Budgeted Corridor Model"
    ]
  },
  {
    "objectID": "src/sections/modelling_multi_specie.html",
    "href": "src/sections/modelling_multi_specie.html",
    "title": "Integer Linear Programming Model",
    "section": "",
    "text": "This model aims to design wildlife corridors and habitat adaptations for multiple species while minimizing costs and ensuring connectivity among origin cells. The model uses a multi-commodity network flow approach with spanning tree constraints for each species, allowing corridors to be shared across species.\n\n\n\nOryctolagus cuniculus\nAtelerix algirus\nEliomys quercinus\nMartes martes\n\n\n\n\n\nObjective: Minimize total cost of corridor construction and habitat adaptation minus benefits from adaptations.\nGoal: Ensure connectivity among origin cells for each species using shared corridors.\nApproach: Multi-commodity network flow with spanning tree constraints.\n\n\n\n\n\n\n\n\n\\[\\begin{align*}\nX_j &=\n\\begin{cases}\n1, & \\text{if there is a corridor in cell $j$, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases} \\\\\n%\nY_{rsjk} &=\n\\begin{cases}\n1, & \\text{if a corridor is built that comes from origin} \\\\\n   & \\text{$r_s$ into cell $j$ with direction toward the} \\\\\n   & \\text{adjacent cell $k$, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases} \\\\\n\\end{align*}\\] \\[\\begin{align*}\n%\nU_{sj} &= \\begin{cases}\n1, & \\text{if species $s$ uses cell $j$ as a corridor, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases}\\\\\n%\nR_{sj} &= \\begin{cases}\n1, & \\text{if cell $j$ is rehabilitated for species $s$, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases} \\\\\n%\nC_{rs} &= \\begin{cases}\n1, & \\text{if origin $r_s$ has a corridor connected} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n\\end{align*}\\]\n\n\n\n\\[\\begin{equation}\n\\begin{aligned}\n\\min z =\\;&\n\\alpha \\left(\n    \\sum_j \\left( c_j X_j + \\sum_{s} a_{sj} R_{sj} \\right)\n    + \\textit{p}\\,(1 - C_{sr})\n\\right) -\n\\\\[3pt]\n&-\n(1-\\alpha)\\left(\n    \\sum_{j=1}^{J} \\sum_{s} b_{sj} R_{sj}\n\\right)\n\\end{aligned}\n\\end{equation}\\]\n\n\n\n\n\\[C_{rs} \\le \\sum_{k \\in A_r} Y_{rs r k} \\le |A_r|\\, C_{rs} \\quad \\forall r, s\\]\n\\[Y_{rs j k} \\le C_{rs} \\quad \\forall r, s, j, k \\in A_j\\]\n\\[\\sum_{i \\in A_j} Y_{rsij} - \\sum_{k \\in A_j} Y_{rsjk} = 0 \\quad \\forall s, r, k \\neq r, j \\notin r_s\\]\n\\[Y_{rs j k} + Y_{rs k j} \\le 1 \\quad \\forall r_s, j \\text{ and } k \\in A_j \\text{ with } j &lt; k\\]\n\\[U_{sj} \\le \\sum_{r} \\sum_{k \\in A_j} Y_{rsjk} + Y_{rskj} \\le \\lambda U_{sj} \\quad \\forall s, j\\]\n\\[\\sum_s U_{sj} \\le \\lambda X_j \\quad \\forall j\\]\n\\[2 U_{\\text{martes},j} + U_{\\text{oryctolagus},j} + U_{\\text{eliomys},j} \\le 2 \\quad \\forall j \\notin r_s\\]\n\\[R_{sj} \\le \\sum_{k \\in A_j} U_{sk} + m \\quad \\forall s, j \\text{ where } m = \\begin{cases} 1 & \\text{if } \\exists k \\in A_j \\mid k \\in r_s \\\\ 0 & \\text{otherwise} \\end{cases}\\]\n\\[2 R_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\n\\[2 U_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\n\\[2 R_{\\text{martes},j} + U_{\\text{oryctolagus},j} + U_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\n\\[\\sum_j c_j U_{sj} \\le B_s^c \\quad \\forall s\\]\n\\[\\sum_j a_{sj} R_{sj} \\le B_s^a \\quad \\forall s\\]\n\\[\\sum_{r,s} C_{rs} \\ge cover \\sum_{s} |r_s|\\]\n\nThe following code block imports the necessary libraries and modules for the model implementation. It includes standard Python libraries (pathlib, sys, time), geospatial data handling (geopandas), and the Gurobi optimization library (gurobipy). Additionally, it imports custom constants and utility functions from the project’s modules to configure the model parameters and visualization tools.\n\n\nCode\nimport pathlib\nimport sys\nimport time\n\nimport geopandas as gpd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Add src to path to enable imports when running as script or importing\nsrc_path = pathlib.Path(__file__).parent.parent\nif str(src_path) not in sys.path:\n    sys.path.insert(0, str(src_path))\n\nfrom models.gurobi.constants import (\n    ALPHA,\n    BUDGET,\n    FOCUS,\n    GAP,\n    HEURISTICS,\n    MIN_COVERAGE_FRACTION,\n    PENALTY_UNCOVERED_ORIGIN,\n    SPECIES,\n)\nfrom models.utils import get_adjacent_cells\nfrom models.visualization import (\n    build_solution_summary,\n    create_solution_map,\n    save_solution_summary,\n)\n\nTIME_LIMIT_SECONDS = 60 * 5",
    "crumbs": [
      "Article",
      "Integer Linear Programming Model"
    ]
  },
  {
    "objectID": "src/sections/modelling_multi_specie.html#model-overview",
    "href": "src/sections/modelling_multi_specie.html#model-overview",
    "title": "Integer Linear Programming Model",
    "section": "",
    "text": "This model aims to design wildlife corridors and habitat adaptations for multiple species while minimizing costs and ensuring connectivity among origin cells. The model uses a multi-commodity network flow approach with spanning tree constraints for each species, allowing corridors to be shared across species.\n\n\n\nOryctolagus cuniculus\nAtelerix algirus\nEliomys quercinus\nMartes martes\n\n\n\n\n\nObjective: Minimize total cost of corridor construction and habitat adaptation minus benefits from adaptations.\nGoal: Ensure connectivity among origin cells for each species using shared corridors.\nApproach: Multi-commodity network flow with spanning tree constraints.\n\n\n\n\n\n\n\n\n\\[\\begin{align*}\nX_j &=\n\\begin{cases}\n1, & \\text{if there is a corridor in cell $j$, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases} \\\\\n%\nY_{rsjk} &=\n\\begin{cases}\n1, & \\text{if a corridor is built that comes from origin} \\\\\n   & \\text{$r_s$ into cell $j$ with direction toward the} \\\\\n   & \\text{adjacent cell $k$, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases} \\\\\n\\end{align*}\\] \\[\\begin{align*}\n%\nU_{sj} &= \\begin{cases}\n1, & \\text{if species $s$ uses cell $j$ as a corridor, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases}\\\\\n%\nR_{sj} &= \\begin{cases}\n1, & \\text{if cell $j$ is rehabilitated for species $s$, and} \\\\\n0, & \\text{otherwise;}\n\\end{cases} \\\\\n%\nC_{rs} &= \\begin{cases}\n1, & \\text{if origin $r_s$ has a corridor connected} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n\\end{align*}\\]\n\n\n\n\\[\\begin{equation}\n\\begin{aligned}\n\\min z =\\;&\n\\alpha \\left(\n    \\sum_j \\left( c_j X_j + \\sum_{s} a_{sj} R_{sj} \\right)\n    + \\textit{p}\\,(1 - C_{sr})\n\\right) -\n\\\\[3pt]\n&-\n(1-\\alpha)\\left(\n    \\sum_{j=1}^{J} \\sum_{s} b_{sj} R_{sj}\n\\right)\n\\end{aligned}\n\\end{equation}\\]\n\n\n\n\n\\[C_{rs} \\le \\sum_{k \\in A_r} Y_{rs r k} \\le |A_r|\\, C_{rs} \\quad \\forall r, s\\]\n\\[Y_{rs j k} \\le C_{rs} \\quad \\forall r, s, j, k \\in A_j\\]\n\\[\\sum_{i \\in A_j} Y_{rsij} - \\sum_{k \\in A_j} Y_{rsjk} = 0 \\quad \\forall s, r, k \\neq r, j \\notin r_s\\]\n\\[Y_{rs j k} + Y_{rs k j} \\le 1 \\quad \\forall r_s, j \\text{ and } k \\in A_j \\text{ with } j &lt; k\\]\n\\[U_{sj} \\le \\sum_{r} \\sum_{k \\in A_j} Y_{rsjk} + Y_{rskj} \\le \\lambda U_{sj} \\quad \\forall s, j\\]\n\\[\\sum_s U_{sj} \\le \\lambda X_j \\quad \\forall j\\]\n\\[2 U_{\\text{martes},j} + U_{\\text{oryctolagus},j} + U_{\\text{eliomys},j} \\le 2 \\quad \\forall j \\notin r_s\\]\n\\[R_{sj} \\le \\sum_{k \\in A_j} U_{sk} + m \\quad \\forall s, j \\text{ where } m = \\begin{cases} 1 & \\text{if } \\exists k \\in A_j \\mid k \\in r_s \\\\ 0 & \\text{otherwise} \\end{cases}\\]\n\\[2 R_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\n\\[2 U_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\n\\[2 R_{\\text{martes},j} + U_{\\text{oryctolagus},j} + U_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\n\\[\\sum_j c_j U_{sj} \\le B_s^c \\quad \\forall s\\]\n\\[\\sum_j a_{sj} R_{sj} \\le B_s^a \\quad \\forall s\\]\n\\[\\sum_{r,s} C_{rs} \\ge cover \\sum_{s} |r_s|\\]\n\nThe following code block imports the necessary libraries and modules for the model implementation. It includes standard Python libraries (pathlib, sys, time), geospatial data handling (geopandas), and the Gurobi optimization library (gurobipy). Additionally, it imports custom constants and utility functions from the project’s modules to configure the model parameters and visualization tools.\n\n\nCode\nimport pathlib\nimport sys\nimport time\n\nimport geopandas as gpd\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Add src to path to enable imports when running as script or importing\nsrc_path = pathlib.Path(__file__).parent.parent\nif str(src_path) not in sys.path:\n    sys.path.insert(0, str(src_path))\n\nfrom models.gurobi.constants import (\n    ALPHA,\n    BUDGET,\n    FOCUS,\n    GAP,\n    HEURISTICS,\n    MIN_COVERAGE_FRACTION,\n    PENALTY_UNCOVERED_ORIGIN,\n    SPECIES,\n)\nfrom models.utils import get_adjacent_cells\nfrom models.visualization import (\n    build_solution_summary,\n    create_solution_map,\n    save_solution_summary,\n)\n\nTIME_LIMIT_SECONDS = 60 * 5",
    "crumbs": [
      "Article",
      "Integer Linear Programming Model"
    ]
  },
  {
    "objectID": "src/sections/modelling_multi_specie.html#model-implementation",
    "href": "src/sections/modelling_multi_specie.html#model-implementation",
    "title": "Integer Linear Programming Model",
    "section": "Model Implementation",
    "text": "Model Implementation\nThe process of implementing the code in Python now continues. In this case, it was done using the Gurobi API, as it was the only model capable of achieving results in a relatively reasonable time.\n\nData Loading\nThe processed dataset containing all cell information is loaded as a GeoDataFrame from a Parquet file. This dataset includes grid cell identifiers, geometric boundaries, species presence indicators, corridor costs, adaptation costs, and adaptation benefits for each cell.\n\nroot_path = pathlib.Path(__file__).parent.parent.parent\ndata_path = root_path / \"data\" / \"processed_dataset.parquet\"\ndf = gpd.read_parquet(data_path)\n\n\n\nConstants and Parameters\nA series of constants are defined that the user must enter when running the model:\n\nBUDGET: Maximum total capital to be invested.\nCORRIDOR_SHARE_BY_SPECIES: Percentage of the total allocated to each species for creating corridors.\nADAPTATION_SHARE_BY_SPECIES: Percentage allocated for adapting cells for each species.\n\nIn this case, the allocation has been made taking into account the extinction risk level of each species as defined in the problem statement. Therefore, those species with the largest allocated budget will benefit from the model.\nHere, too, all the dictionaries that will collect each of the parameters established above are established.\n\nBUDGET: float = 500.0\n\nCORRIDOR_SHARE_BY_SPECIES: dict[str, float] = {\n    \"oryctolagus_cuniculus\": 0.30,\n    \"eliomys_quercinus\": 0.24,\n    \"atelerix_algirus\": 0.14,\n    \"martes_martes\": 0.12,\n}\nADAPTATION_SHARE_BY_SPECIES: dict[str, float] | None = {\n    \"oryctolagus_cuniculus\": 0.07,\n    \"eliomys_quercinus\": 0.06,\n    \"atelerix_algirus\": 0.04,\n    \"martes_martes\": 0.03,\n}\n\norigin_cells_by_species = {}\n\nfor species in SPECIES:\n    column_name = f\"has_{species}\"\n    species_cells = df[df[column_name]][\"grid_id\"].tolist()\n\n    if len(species_cells) &gt; 0:\n        origin_cells_by_species[species] = species_cells\n    else:\n        print(f\"Warning: No cells found for species {species}\")\n        origin_cells_by_species[species] = []\n\nall_cells = df[\"grid_id\"].tolist()\n\nprint(f\"\\nTotal cells in the grid: {len(all_cells)}\")\nprint(\"\\nOrigin cells by species:\")\nfor species in SPECIES:\n    print(f\"  {species}:\")\n    print(f\"    - Origins: {len(origin_cells_by_species[species])}\")\n    if len(origin_cells_by_species[species]) &gt; 0:\n        print(f\"    - First 5 cells: {origin_cells_by_species[species][:5]}\")\n\nall_cells_set = set(all_cells)\nadjacency = {}\n\nfor cell in all_cells:\n    adjacency[cell] = get_adjacent_cells(cell, all_cells_set, df)\n\nprint(\"\\nExample adjacencies:\")\nfor i, cell in enumerate(all_cells[:3]):\n    print(f\"{cell}: {adjacency[cell]}\")\n    geom_cell = df[df[\"grid_id\"] == cell][\"geometry\"].values[0]\n    for j, neighbor in enumerate(adjacency[cell]):\n        geom_neighbor = df[df[\"grid_id\"] == neighbor][\"geometry\"].values[0]\n        print(\n            \"Touches:\",\n            neighbor,\n            geom_cell.touches(geom_neighbor),\n        )\n\n# ============================================================================\n# PARAMETERS DICTIONARIES\n# ============================================================================\n\ncost_corridor_dict = dict(zip(df[\"grid_id\"], df[\"cost_corridor\"]))\n\nprint(\"\\nExample corridor costs:\")\nfor cell in all_cells[:5]:\n    print(f\"{cell}: {cost_corridor_dict[cell]:.2f}\")\n\ncost_adaptation_dict = {}\nfor j in all_cells:\n    for species in SPECIES:\n        cost_adaptation_dict[(species, j)] = df[df[\"grid_id\"] == j][\n            f\"cost_adaptation_{species.split('_')[0]}\"\n        ].values[0]\n\nprint(\"\\nExample adaptation costs:\")\nfor species in SPECIES:\n    for cell in all_cells[:5]:\n        print(f\"{species}, {cell}: {cost_adaptation_dict[(species, cell)]:.2f}\")\n\nbenefit_adaptation_dict = {}\nfor j in all_cells:\n    for species in SPECIES:\n        benefit_adaptation_dict[(species, j)] = df[df[\"grid_id\"] == j][\n            f\"{species.split('_')[1]}_benefit\"\n        ].values[0]\n\nprint(\"\\nExample adaptation benefits:\")\nfor species in SPECIES:\n    for cell in all_cells[:5]:\n        print(f\"{species}, {cell}: {benefit_adaptation_dict[(species, cell)]:.2f}\")\n\n\n\nBudget Preparation\nThis function validates and computes the budget allocation for corridors and adaptations per species. It ensures that the sum of corridor and adaptation shares does not exceed 100% of the total budget, and returns the calculated budget amounts for each species.\n\ndef _prepare_budget_shares(\n    species_list, total_budget, corridor_shares, adaptation_shares\n):\n    corridor_share_total = sum(corridor_shares.get(sp, 0.0) for sp in species_list)\n    if corridor_share_total &gt; 1.0 + 1e-9:\n        raise ValueError(\n            f\"Corridor shares sum to {corridor_share_total:.3f} &gt; 1.0; reduce CORRIDOR_SHARE_BY_SPECIES.\"\n        )\n\n    if adaptation_shares is None:\n        remaining = max(0.0, 1.0 - corridor_share_total)\n        adaptation_shares = {sp: remaining / len(species_list) for sp in species_list}\n    adaptation_share_total = sum(adaptation_shares.get(sp, 0.0) for sp in species_list)\n\n    if corridor_share_total + adaptation_share_total &gt; 1.0 + 1e-9:\n        raise ValueError(\n            f\"Corridor+adaptation shares sum to {corridor_share_total + adaptation_share_total:.3f} &gt; 1.0; reduce percentages.\"\n        )\n\n    corridor_budget_by_species = {\n        sp: total_budget * corridor_shares.get(sp, 0.0) for sp in species_list\n    }\n    adaptation_budget_by_species = {\n        sp: total_budget * adaptation_shares.get(sp, 0.0) for sp in species_list\n    }\n    return (\n        corridor_budget_by_species,\n        adaptation_budget_by_species,\n        corridor_share_total,\n        adaptation_share_total,\n    )\n\n\n(\n    corridor_budget_by_species,\n    adaptation_budget_by_species,\n    corridor_share_total,\n    adaptation_share_total,\n) = _prepare_budget_shares(\n    SPECIES, BUDGET, CORRIDOR_SHARE_BY_SPECIES, ADAPTATION_SHARE_BY_SPECIES\n)\n\nprint(\"=\" * 60)\nprint(\n    \"\\nBudgets configured:\"\n    f\"\\n  Total: {BUDGET:.2f}\"\n    f\"\\n  Corridors (sum shares): {corridor_share_total:.2f}\"\n    f\"\\n  Adaptation (sum shares): {adaptation_share_total:.2f}\"\n)\nfor sp in SPECIES:\n    print(\n        f\"    {sp}: corridors {corridor_budget_by_species.get(sp, 0.0):.2f} | \"\n        f\"adaptation {adaptation_budget_by_species.get(sp, 0.0):.2f}\"\n    )\n\n\n\nModel Creation\nThe Gurobi model object is instantiated here. This model will hold all decision variables, constraints, and the objective function for the wildlife corridor optimization problem.\n\nmodel = gp.Model(\"WildlifeCorridors\")\n\nprint(f\"\\n   Gurobi version: {gp.gurobi.version()}\")\n\n\n\nDecision Variables\nThe decision variables are created as binary variables in the Gurobi model. Variable \\(X_j\\) indicates whether a corridor is built in cell \\(j\\). Variable \\(Y_{rsjk}\\) represents the flow direction from origin \\(r\\) of species \\(s\\) through cell \\(j\\) toward adjacent cell \\(k\\). The covered variable tracks whether each origin cell is connected to the corridor network. Variables \\(U_{sj}\\) and rehab (for \\(R_{sj}\\)) indicate species corridor usage and habitat rehabilitation respectively.\n\nx = {}\nfor j in all_cells:\n    x[j] = model.addVar(vtype=GRB.BINARY, name=f\"x_{j}\")\n\n\n\ny = {}\nfor species in SPECIES:\n    origin_cells = origin_cells_by_species[species]\n    for r in origin_cells:\n        for j in all_cells:\n            for k in adjacency[j]:\n                y[(species, r, j, k)] = model.addVar(\n                    vtype=GRB.BINARY, name=f\"y_{species}_{r}_{j}_{k}\"\n                )\n\nfor species in SPECIES:\n    species_vars = sum(1 for key in y.keys() if key[0] == species)\n    print(f\"    {species}: {species_vars}\")\n\n\ncovered = {}\nfor species in SPECIES:\n    for origin in origin_cells_by_species[species]:\n        covered[(species, origin)] = model.addVar(\n            vtype=GRB.BINARY, name=f\"covered_{species}_{origin}\"\n        )\n\nu = {}\nrehab = {}\nfor species in SPECIES:\n    origin_cells = origin_cells_by_species[species]\n    for j in all_cells:\n        u[(species, j)] = model.addVar(vtype=GRB.BINARY, name=f\"u_{species}_{j}\")\n\n        if j not in origin_cells:\n            rehab[(species, j)] = model.addVar(\n                vtype=GRB.BINARY, name=f\"rehab_{species}_{j}\"\n            )\n\n\nmodel.update()\n\n\n\nObjective Function\nThe objective function is implemented by combining construction costs, adaptation costs, and adaptation benefits. The parameter \\(\\alpha\\) controls the trade-off between minimizing costs and maximizing benefits. A penalty term is added for each uncovered origin cell to encourage full connectivity.\n\ncost = gp.LinExpr()\nbenefit = gp.LinExpr()\n\nfor j in x.keys():\n    cost += cost_corridor_dict[j] * x[j]\n    for species in SPECIES:\n        if (species, j) in rehab:\n            cost += cost_adaptation_dict[(species, j)] * rehab[(species, j)]\n\nfor j in x.keys():\n    for species in SPECIES:\n        if (species, j) in rehab:\n            benefit += benefit_adaptation_dict[(species, j)] * rehab[(species, j)]\n\nif PENALTY_UNCOVERED_ORIGIN is not None:\n    for var in covered.values():\n        cost += PENALTY_UNCOVERED_ORIGIN * (1 - var)\n\nmodel.setObjective((ALPHA * cost) - ((1 - ALPHA) * benefit), GRB.MINIMIZE)\n\nprint(\"Objective function set: Minimize total corridor construction cost\")\n\n\n\nConstraints\n\nOptional outgoing corridor per origin\n\\[C_{rs} \\le \\sum_{k \\in A_r} Y_{rs r k} \\le |A_r|\\, C_{rs} \\quad \\forall r, s\\]\nThis constraint ensures that if an origin cell \\(r\\) of species \\(s\\) is marked as covered (\\(C_{rs} = 1\\)), then at least one outgoing flow arc must exist from that origin to an adjacent cell. The upper bound limits the outflow to at most the number of adjacent cells when covered.\n\nfor species in SPECIES:\n    origin_cells = origin_cells_by_species[species]\n    for r in origin_cells:\n        outflow = gp.LinExpr()\n        deg_r = max(1, len(adjacency[r]))\n\n        for j in adjacency[r]:\n            outflow += y[(species, r, r, j)]\n\n        model.addConstr(\n            outflow &gt;= covered[(species, r)],\n            name=f\"origin_outflow_min_{species}_{r}\",\n        )\n        model.addConstr(\n            outflow &lt;= deg_r * covered[(species, r)],\n            name=f\"origin_outflow_max_{species}_{r}\",\n        )\n\n\n\nFlow variables bounded by origin coverage\n\\[Y_{rs j k} \\le C_{rs} \\quad \\forall r, s, j, k \\in A_j\\]\nThis constraint ensures that flow variables \\(Y_{rsjk}\\) can only be active if the corresponding origin \\(r\\) for species \\(s\\) is covered. If an origin is not connected to the corridor network (\\(C_{rs} = 0\\)), no flow can emanate from it through any cell.\n\nfor species in SPECIES:\n    origin_cells = origin_cells_by_species[species]\n    for r in origin_cells:\n        for j in all_cells:\n            for k in adjacency[j]:\n                if (species, r, j, k) in y:\n                    model.addConstr(\n                        y[(species, r, j, k)] &lt;= covered[(species, r)],\n                        name=f\"origin_flow_bound_{species}_{r}_{j}_{k}\",\n                    )\n\n\n\nFlow conservation at intermediate nodes\n\\[\\sum_{i \\in A_j} Y_{rsij} - \\sum_{k \\in A_j} Y_{rsjk} = 0 \\quad \\forall s, r, k \\neq r, j \\notin r_s\\]\nThis constraint enforces flow conservation at all intermediate cells (non-origin cells). For each cell \\(j\\) that is not an origin, the total incoming flow from adjacent cells must equal the total outgoing flow, ensuring that corridors form continuous paths without flow accumulation at intermediate nodes.\n\nfor species in SPECIES:\n    origin_cells = origin_cells_by_species[species]\n\n    for r in origin_cells:\n        for j in all_cells:\n            if j in origin_cells:\n                continue\n\n            flow_balance = gp.LinExpr()\n\n            for i in adjacency[j]:\n                flow_balance += y[(species, r, i, j)]\n\n            for k in adjacency[j]:\n                if k != r:\n                    flow_balance -= y[(species, r, j, k)]\n\n            model.addConstr(\n                flow_balance == 0, name=f\"flow_conservation_{species}_{r}_{j}\"\n            )\n\n\n\nNo reverse flow on edges\n\\[Y_{rs j k} + Y_{rs k j} \\le 1 \\quad \\forall r_s, j \\text{ and } k \\in A_j \\text{ with } j &lt; k\\]\nThis constraint prevents bidirectional flow on the same edge between two adjacent cells. For any pair of cells \\(j\\) and \\(k\\), at most one direction of flow is allowed (\\(Y_{rsjk} + Y_{rskj} \\le 1\\)), which helps maintain a tree structure in the corridor network.\n\nfor species in SPECIES:\n    origin_cells = origin_cells_by_species[species]\n\n    for r in origin_cells:\n        for j in all_cells:\n            for k in adjacency[j]:\n                if j &lt; k:\n                    if (species, r, j, k) in y and (species, r, k, j) in y:\n                        model.addConstr(\n                            y[(species, r, j, k)] + y[(species, r, k, j)] &lt;= 1,\n                            name=f\"no_reverse_flow_{species}_{r}_{j}_{k}\",\n                        )\n\n\n\nFlow only on built corridors\n\\[U_{sj} \\le \\sum_{r} \\sum_{k \\in A_j} Y_{rsjk} + Y_{rskj} \\le \\lambda U_{sj} \\quad \\forall s, j\\]\nThis constraint links the flow variables \\(Y\\) with the species usage variable \\(U_{sj}\\). A cell \\(j\\) is marked as used by species \\(s\\) (\\(U_{sj} = 1\\)) if and only if there is at least one flow arc passing through it. The big-M formulation ensures proper activation of the usage indicator.\n\nfor species in SPECIES:\n    for j in all_cells:\n        flow_sum = gp.LinExpr()\n        m_cell_count = 0\n        for r in origin_cells_by_species[species]:\n            for k in adjacency[j]:\n                if (species, r, j, k) in y:\n                    flow_sum += y[(species, r, j, k)]\n                    flow_sum += y[(species, r, k, j)]\n                    m_cell_count += 2\n\n        M_cell = max(1, m_cell_count)\n        model.addConstr(\n            flow_sum &lt;= M_cell * u[(species, j)], name=f\"flow_on_built_{species}_{j}\"\n        )\n        model.addConstr(\n            u[(species, j)] &lt;= flow_sum, name=f\"built_if_flow_{species}_{j}\"\n        )\n\n\n\nLinking u and x variables\n\\[\\sum_s U_{sj} \\le \\lambda X_j \\quad \\forall j\\]\nThis constraint ensures that a corridor cell \\(X_j\\) is activated if any species uses that cell. If at least one species has \\(U_{sj} = 1\\), then \\(X_j\\) must be 1. This allows corridors to be shared across multiple species while ensuring the corridor is marked as built.\n\nfor j in all_cells:\n    species_count = 0\n    lhs = gp.LinExpr()\n    for species in SPECIES:\n        lhs += u[(species, j)]\n        species_count += 1\n    M_species = species_count\n    model.addConstr(lhs &lt;= M_species * x[j], name=f\"u_x_link_{j}\")\n\n\n\nIncompatibility Martes martes - Oryctolagus cuniculus and Eliomys quercinus\n\\[2 U_{\\text{martes},j} + U_{\\text{oryctolagus},j} + U_{\\text{eliomys},j} \\le 2 \\quad \\forall j \\notin r_s\\]\nThis constraint models the ecological incompatibility between Martes martes (a predator) and its prey species (Oryctolagus cuniculus and Eliomys quercinus). The weighted inequality ensures that if Martes martes uses a corridor cell, then neither of the prey species can use the same cell simultaneously as a corridor.\n\nmartes_origin_cells = origin_cells_by_species.get(\"martes_martes\", [])\noryctolagus_origin_cells = origin_cells_by_species.get(\"oryctolagus_cuniculus\", [])\neliomys_origin_cells = origin_cells_by_species.get(\"eliomys_quercinus\", [])\n\nfor j in all_cells:\n    if j in martes_origin_cells and (\n        j in oryctolagus_origin_cells or j in eliomys_origin_cells\n    ):\n        continue\n\n    model.addConstr(\n        2 * u.get((\"martes_martes\", j), 0)\n        + u.get((\"oryctolagus_cuniculus\", j), 0)\n        + u.get((\"eliomys_quercinus\", j), 0)\n        &lt;= 2,\n        name=f\"incompatibility_martes_oryctolagus_{j}\",\n    )\n\n\n\nAdaptation only if adjacent corridor or origin is built\n\\[R_{sj} \\le \\sum_{k \\in A_j} U_{sk} + m \\quad \\forall s, j \\text{ where } m = \\begin{cases} 1 & \\text{if } \\exists k \\in A_j \\mid k \\in r_s \\\\ 0 & \\text{otherwise} \\end{cases}\\]\nThis constraint ensures that a cell can only be rehabilitated for a species if there is at least one adjacent cell that is part of that species’ corridor network, or if the cell is adjacent to an origin cell. This guarantees that adapted habitats are connected to the corridor system.\n\nfor species in SPECIES:\n    origins = origin_cells_by_species[species]\n    for j in all_cells:\n        if (species, j) not in rehab:\n            continue\n        adj_corridors = gp.LinExpr()\n\n        touches_origin = 0\n        for k in adjacency[j]:\n            adj_corridors += u[(species, k)]\n            if k in origins:\n                touches_origin = 1\n\n        model.addConstr(\n            rehab[(species, j)] &lt;= adj_corridors + touches_origin,\n            name=f\"rehab_adjacent_{species}_{j}\",\n        )\n\n\n\nAdaptation compatibility\n\\[2 R_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\nSimilar to the corridor incompatibility constraint, this ensures that habitat adaptations respect predator-prey relationships. A cell cannot be adapted for Martes martes if it is also adapted for Oryctolagus cuniculus or Eliomys quercinus, preventing conflicting habitat modifications in the same location.\n\nfor j in all_cells:\n    model.addConstr(\n        2 * rehab.get((\"martes_martes\", j), 0)\n        + rehab.get((\"oryctolagus_cuniculus\", j), 0)\n        + rehab.get((\"eliomys_quercinus\", j), 0)\n        &lt;= 2,\n        name=f\"rehab_compatibility_{j}\",\n    )\n\n\n\nCorridor for martes or Adaptation for oryctolagus and eliomys\n\\[2 U_{\\text{martes},j} + R_{\\text{oryctolagus},j} + R_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\nThis constraint prevents a cell from being used as a corridor by Martes martes while simultaneously being adapted for Oryctolagus cuniculus or Eliomys quercinus. This extends the predator-prey incompatibility to cross-interactions between corridor usage and habitat adaptation.\n\nfor j in all_cells:\n    model.addConstr(\n        2 * u.get((\"martes_martes\", j), 0)\n        + rehab.get((\"oryctolagus_cuniculus\", j), 0)\n        + rehab.get((\"eliomys_quercinus\", j), 0)\n        &lt;= 2,\n        name=f\"corridor_adaptation_compatibility_{j}\",\n    )\n\n\n\nAdaptation for martes or Corridor for oryctolagus and eliomys\n\\[2 R_{\\text{martes},j} + U_{\\text{oryctolagus},j} + U_{\\text{eliomys},j} \\le 2 \\quad \\forall j\\]\nThis is the complementary constraint to the previous one. It prevents a cell from being adapted for Martes martes if it is being used as a corridor by Oryctolagus cuniculus or Eliomys quercinus, ensuring complete separation between predator and prey habitat modifications and movements.\n\nfor j in all_cells:\n    model.addConstr(\n        2 * rehab.get((\"martes_martes\", j), 0)\n        + u.get((\"oryctolagus_cuniculus\", j), 0)\n        + u.get((\"eliomys_quercinus\", j), 0)\n        &lt;= 2,\n        name=f\"adaptation_corridor_compatibility_{j}\",\n    )\n\n\n\nBudget constraint: Per-species corridor budgets and per-species adaptation budgets\n\\[\\sum_j c_j U_{sj} \\le B_s^c \\quad \\forall s\\]\n\\[\\sum_j a_{sj} R_{sj} \\le B_s^a \\quad \\forall s\\]\nThese constraints enforce the budget limitations for each species. The first loop ensures that the total cost of corridor cells used by each species does not exceed its allocated corridor budget (\\(B_s^c\\)). The second loop ensures that the total adaptation costs for each species stay within its adaptation budget (\\(B_s^a\\)).\n\nfor species in SPECIES:\n    cap = corridor_budget_by_species.get(species, 0.0)\n    corridor_cost_species = gp.LinExpr()\n    for j in all_cells:\n        corridor_cost_species += cost_corridor_dict[j] * u[(species, j)]\n    model.addConstr(corridor_cost_species &lt;= cap, name=f\"budget_corridor_{species}\")\n\nfor species in SPECIES:\n    cap = adaptation_budget_by_species.get(species, 0.0)\n    adaptation_cost_species = gp.LinExpr()\n    for j in all_cells:\n        if (species, j) in rehab:\n            adaptation_cost_species += (\n                cost_adaptation_dict[(species, j)] * rehab[(species, j)]\n            )\n    model.addConstr(adaptation_cost_species &lt;= cap, name=f\"budget_adaptation_{species}\")\n\n\n\nMinimum coverage fraction\n\\[\\sum_{r,s} C_{rs} \\ge cover \\sum_{s} |r_s|\\]\nThis optional constraint ensures that at least a specified fraction of all origin cells across all species are covered by the corridor network. The MIN_COVERAGE_FRACTION parameter (e.g., 0.8 for 80%) determines the minimum proportion of origins that must be connected.\n\nif MIN_COVERAGE_FRACTION is not None and covered:\n    total_origins = len(covered)\n    required = MIN_COVERAGE_FRACTION * total_origins\n    model.addConstr(\n        gp.quicksum(covered.values()) &gt;= required,\n        name=\"min_coverage_fraction\",\n    )\n\n\n\n\nSolving the model and results\nThe model is configured with performance parameters before solving: a time limit prevents excessive computation, MIPGap controls the acceptable optimality gap, MIPFocus directs the solver’s strategy, and Heuristics controls the effort spent on finding feasible solutions quickly. After optimization, the solution status is checked and key metrics (objective value, total cost, runtime) are reported.\n\n# --- PERFORMANCE CONFIGURATION ---\n\nmodel.setParam(\"TimeLimit\", TIME_LIMIT_SECONDS)\n\nmodel.setParam(\"MIPGap\", GAP)\n\nmodel.setParam(\"MIPFocus\", FOCUS)\n\nmodel.setParam(\"Heuristics\", HEURISTICS)\n\n# --- END OF PERFORMANCE CONFIGURATION ---\n\nstart_time = time.time()\n\nmodel.optimize()\n\nelapsed_time = time.time() - start_time\n\n# Calculate the total cost with the obtained solution\ntotal_cost = 0.0\nif model.SolCount &gt; 0:\n    for j in x.keys():\n        if x[j].X &gt; 0.5:\n            total_cost += cost_corridor_dict[j]\n        for species in SPECIES:\n            if (species, j) in rehab and rehab[(species, j)].X &gt; 0.5:\n                total_cost += cost_adaptation_dict[(species, j)]\n\nprint(f\"Solution status: {model.Status}\")\n\nif model.Status == GRB.OPTIMAL:\n    print(\"✓ OPTIMAL solution found!\")\nelif model.Status == GRB.TIME_LIMIT and model.SolCount &gt; 0:\n    print(\"✓ FEASIBLE solution found (time limit reached, not proven optimal)\")\nelif model.Status in [GRB.SUBOPTIMAL] or model.SolCount &gt; 0:\n    print(\"✓ FEASIBLE solution found (not proven optimal)\")\nelse:\n    print(\"✗ No solution found\")\n\nif model.SolCount &gt; 0:\n    print(f\"\\nObjective value: {model.ObjVal:.2f}\")\n    print(f\"Total cost: {total_cost:.2f}\")\n    print(f\"Number of variables: {model.NumVars}\")\n    print(f\"Number of constraints: {model.NumConstrs}\")\n    print(f\"Solver runtime: {model.Runtime:.2f} seconds\")\n    print(f\"Actual elapsed time: {elapsed_time:.2f} seconds\")\n\n\n\nSolution Visualization\nTo observe the solutions, the folium library is used. In this case, the solver was solved with three different configurations for the alpha.\n\n\nCode\nfrom pathlib import Path\nimport sys\nimport geopandas as gpd\nfrom folium.plugins import Fullscreen\n\n# Navigate to the src directory which contains the models package\nsrc_path = Path(__file__).parent.parent if \"__file__\" in dir() else Path(\".\").resolve().parent\nif str(src_path) not in sys.path:\n    sys.path.insert(0, str(src_path))\n\n# Alternative: if running from the document directory, try multiple paths\nfor potential_path in [Path(\".\").parent, Path(\".\").parent.parent, Path(\"..\"), Path(\"../src\")]:\n    resolved = potential_path.resolve()\n    if (resolved / \"models\").exists() and str(resolved) not in sys.path:\n        sys.path.insert(0, str(resolved))\n        break\n\nfrom models.visualization import (\n    load_solution_summary,\n    create_solution_map,\n    compute_solution_cost,\n    format_cost_table,\n    )\n\ndata_path = src_path.parent / \"data\"\nsummaries_path = data_path / \"experiments\" / \"summaries\"\ndf = gpd.read_parquet(data_path / \"processed_dataset.parquet\")\n\nalpha_05 = load_solution_summary(summaries_path / \"modelling_multi_species_alpha_0.5_summary.json\")\nalpha_075 = load_solution_summary(summaries_path / \"modelling_multi_species_alpha_0.75_summary.json\")\nalpha_025 = load_solution_summary(summaries_path / \"modelling_multi_species_alpha_0.25_summary.json\")\n\n\ncreate_solution_map(\n    df,\n    alpha_05,\n)\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nMap of the solution obtained with alpha = 0.5\n\n\n\n\nCode\nformat_cost_table(compute_solution_cost(alpha_05, df, alpha=0.5), title=\"Cost Breakdown (α = 0.5)\")\n\n\n\n        Cost Breakdown (α = 0.5)\n        \n\n\n\n\n\n\n\nComponent\nValue\n\n\n\n\nCorridor Cost\n316.45\n\n\nAdaptation Cost\n99.18\n\n\n↳ Oryctolagus Cuniculus\n34.95\n\n\n↳ Atelerix Algirus\n19.65\n\n\n↳ Eliomys Quercinus\n29.94\n\n\n↳ Martes Martes\n14.64\n\n\nTotal Cost\n415.63\n\n\nTotal Benefit\n1159.40\n\n\n↳ Oryctolagus Cuniculus\n422.84\n\n\n↳ Atelerix Algirus\n245.52\n\n\n↳ Eliomys Quercinus\n313.72\n\n\n↳ Martes Martes\n177.32\n\n\nObjective (z)\nα=0.5 · (cost + penalty) − (1−α) · benefit\n8628.12\n\n\n\n\n    \n\n\n\n\nCode\ncreate_solution_map(\n    df,\n    alpha_075,\n)\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nMap of the solution obtained with alpha = 0.75\n\n\n\n\nCode\nformat_cost_table(compute_solution_cost(alpha_075, df, alpha=0.75), title=\"Cost Breakdown (α = 0.75)\")\n\n\n\n        Cost Breakdown (α = 0.75)\n        \n\n\n\n\n\n\n\nComponent\nValue\n\n\n\n\nCorridor Cost\n289.98\n\n\nAdaptation Cost\n98.88\n\n\n↳ Oryctolagus Cuniculus\n34.56\n\n\n↳ Atelerix Algirus\n19.72\n\n\n↳ Eliomys Quercinus\n29.76\n\n\n↳ Martes Martes\n14.84\n\n\nTotal Cost\n388.86\n\n\nTotal Benefit\n1141.67\n\n\n↳ Oryctolagus Cuniculus\n409.20\n\n\n↳ Atelerix Algirus\n245.52\n\n\n↳ Eliomys Quercinus\n309.63\n\n\n↳ Martes Martes\n177.32\n\n\nObjective (z)\nα=0.75 · (cost + penalty) − (1−α) · benefit\n13506.23\n\n\n\n\n    \n\n\n\n\nCode\ncreate_solution_map(\n    df,\n    alpha_025,\n)\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook\nMap of the solution obtained with alpha = 0.25\n\n\n\n\nCode\nformat_cost_table(compute_solution_cost(alpha_025, df, alpha=0.25), title=\"Cost Breakdown (α = 0.25)\")\n\n\n\n        Cost Breakdown (α = 0.25)\n        \n\n\n\n\n\n\n\nComponent\nValue\n\n\n\n\nCorridor Cost\n319.60\n\n\nAdaptation Cost\n97.23\n\n\n↳ Oryctolagus Cuniculus\n34.27\n\n\n↳ Atelerix Algirus\n19.39\n\n\n↳ Eliomys Quercinus\n28.93\n\n\n↳ Martes Martes\n14.64\n\n\nTotal Cost\n416.83\n\n\nTotal Benefit\n1145.76\n\n\n↳ Oryctolagus Cuniculus\n422.84\n\n\n↳ Atelerix Algirus\n245.52\n\n\n↳ Eliomys Quercinus\n300.08\n\n\n↳ Martes Martes\n177.32\n\n\nObjective (z)\nα=0.25 · (cost + penalty) − (1−α) · benefit\n3744.89",
    "crumbs": [
      "Article",
      "Integer Linear Programming Model"
    ]
  }
]